"use strict";(self.webpackChunkevcc_docs=self.webpackChunkevcc_docs||[]).push([[8266],{1530:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var r=i(85893),t=i(11151);const s={sidebar_position:4},o="Modbus",d={id:"reference/modbus",title:"Modbus",description:"Some devices, such as meters (meters) or chargers (chargers), are connected and addressed using the Modbus protocol.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/reference/modbus.md",sourceDirName:"reference",slug:"/reference/modbus",permalink:"/en/docs/reference/modbus",draft:!1,unlisted:!1,editUrl:"https://github.com/evcc-io/docs/tree/main/i18n/en/docusaurus-plugin-content-docs/current/reference/modbus.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Plugins",permalink:"/en/docs/reference/plugins"},next:{title:"API",permalink:"/en/docs/reference/api"}},c={},a=[{value:"Physical Connection",id:"physical-connection",level:2},{value:"Serial Connection (RS485)",id:"serial-connection-rs485",level:3},{value:"Direct Network Connection",id:"direct-network-connection",level:3},{value:"Serial Device via Network Connection (with Interface Converter)",id:"serial-device-via-network-connection-with-interface-converter",level:3},{value:"Predefined Devices",id:"predefined-devices",level:2},{value:"Manual Configuration",id:"manual-configuration",level:2},{value:"Writing Registers",id:"writing-registers",level:3},{value:"Complete Example",id:"complete-example",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"modbus",children:"Modbus"}),"\n",(0,r.jsxs)(n.p,{children:["Some devices, such as meters (",(0,r.jsx)(n.a,{href:"/docs/reference/configuration/meters#modbus",children:(0,r.jsx)(n.code,{children:"meters"})}),") or chargers (",(0,r.jsx)(n.a,{href:"/docs/reference/configuration/chargers",children:(0,r.jsx)(n.code,{children:"chargers"})}),"), are connected and addressed using the Modbus protocol."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"meter"})," configuration includes the type of physical connection (interface), optional technical interface parameters, the Modbus protocol used, the unique Modbus ID of the device on the bus, and the number and type of the register to be read or written."]}),"\n",(0,r.jsx)(n.p,{children:"It is important to note that there are three different Modbus protocols: Modbus RTU, Modbus ASCII, and Modbus TCP. These can technically be transmitted over different types of interfaces. The classic version is Modbus RTU over a serial RS485 bus interface, commonly used with most meters or some chargers. Devices with a native network interface (Ethernet/WiFi), on the other hand, are typically addressed using the Modbus TCP protocol."}),"\n",(0,r.jsx)(n.p,{children:'If a serial Modbus device needs to be connected through an interface converter via a network (Ethernet/WiFi/PowerLAN), Modbus RTU protocol over a TCP/IP connection is established. The Modbus RTU protocol is directly transmitted over the network (i.e., "tunnelled"). Even though the transport method (TCP/IP) is the same, the protocol is NOT the same as Modbus TCP. It\'s essential to distinguish between the protocol and the transport method. "Modbus (RTU) over TCP" is different from Modbus TCP!'}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsx)(n.p,{children:"Caution: There are more complex interface converters that can optionally translate the Modbus protocol itself between Modbus RTU and Modbus TCP!\nIf this feature is active, evcc must communicate with the converter using Modbus TCP, while the converter communicates with the serial device via Modbus RTU and bidirectionally translates the two protocols.\nIn this case, careful attention must be paid to the device specification and configuration; otherwise, communication might not work!"})}),"\n",(0,r.jsx)(n.p,{children:"In the case of a configuration with an interface converter, the serial bus configuration is determined only on the converter. The evcc configuration then concerns only the section up to the converter."}),"\n",(0,r.jsx)(n.h2,{id:"physical-connection",children:"Physical Connection"}),"\n",(0,r.jsx)(n.h3,{id:"serial-connection-rs485",children:"Serial Connection (RS485)"}),"\n",(0,r.jsxs)(n.p,{children:["If the device is directly connected via an RS485 adapter (Modbus RTU), ",(0,r.jsx)(n.code,{children:"device"})," and the serial communication parameters ",(0,r.jsx)(n.code,{children:"baudrate"})," and ",(0,r.jsx)(n.code,{children:"comset"})," must be specified according to the device configuration. Please refer to the respective user manual, data sheets, or system settings."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Multiple devices with identical communication parameters can be operated on a serial RS485 bus if each device is assigned a unique Modbus ID. If not all devices on a bus can be configured with uniform communication settings (but with different IDs), splitting into multiple independent bus systems is necessary."})}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsx)(n.p,{children:"Mixing devices with different serial communication parameters on a bus is not possible and leads to unpredictable communication errors."})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'source: modbus\nid: 1\ndevice: /dev/ttyUSB0\nbaudrate: 38400\ncomset: "8E1"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"direct-network-connection",children:"Direct Network Connection"}),"\n",(0,r.jsxs)(n.p,{children:["If the device is directly connected via a native network connection (Modbus TCP), a ",(0,r.jsx)(n.code,{children:"uri"})," consisting of HOSTNAME",":PORT"," or IP",":PORT"," must be provided:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\nid: 1\nuri: 192.168.0.11:502\n"})}),"\n",(0,r.jsx)(n.h3,{id:"serial-device-via-network-connection-with-interface-converter",children:"Serial Device via Network Connection (with Interface Converter)"}),"\n",(0,r.jsxs)(n.p,{children:["If a serial device is connected via an intermediate transparent RS485-IP interface converter (without protocol translation), the protocol must also be switched to Modbus RTU over the TCP/IP connection using ",(0,r.jsx)(n.code,{children:"rtu: true"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\nid: 1\nuri: 192.168.0.10:502\nrtu: true # Modbus RTU over TCP\n"})}),"\n",(0,r.jsx)(n.h2,{id:"predefined-devices",children:"Predefined Devices"}),"\n",(0,r.jsxs)(n.p,{children:["The integrated predefined device models ",(0,r.jsx)(n.code,{children:"model"})," are identical to ",(0,r.jsx)(n.a,{href:"https://github.com/volkszaehler/mbmd/blob/master/docs/mbmd_run.md#options",children:"MBMD"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"ABB       ABB A/B-Series meters\nDDM       DDM18SD\nDZG       DZG Metering GmbH DVH4013 meters\nIEM3000   Schneider Electric iEM3000 series\nINEPRO    Inepro Metering Pro 380\nJANITZA   Janitza meters\nMPM       Bernecker Engineering MPM3PM meters\nORNO1P    ORNO WE-514 & WE-515\nORNO1P504 ORNO WE-504\nORNO3P    ORNO WE-516 & WE-517\nSBC       Saia Burgess Controls ALE3 meters\nSDM       Eastron SDM630/120/72DMv2\nSDM220    Eastron SDM220\nSDM230    Eastron SDM230\nSDM72     Eastron SDM72\nSEMTR     SolarEdge SE-MTR-3Y"}),"\n",(0,r.jsxs)(n.p,{children:["Any ",(0,r.jsx)(n.code,{children:"model"})," that deviates from these is"]}),"\n",(0,r.jsxs)(n.p,{children:["treated as a ",(0,r.jsx)(n.em,{children:"SunSpec"})," device type."]}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"value"})," to define the value to be read from the device. All supported values are predefined in ",(0,r.jsx)(n.a,{href:"https://github.com/volkszaehler/mbmd/blob/master/meters/measurements.go#L28",children:"MBMD"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In the case of a ",(0,r.jsx)(n.em,{children:"SunSpec"}),"-compatible inverter or meter, the values to be read are specified in the format ",(0,r.jsx)(n.code,{children:"model:[block:]point"})," according to the ",(0,r.jsx)(n.em,{children:"SunSpec"})," definition. For example, querying the DC power on the second string of a three-phase PV inverter (corresponding to SunSpec Model 103) is done as follows: ",(0,r.jsx)(n.code,{children:"value: 103:2:W"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The device ",(0,r.jsx)(n.code,{children:"model"})," and the slave ID ",(0,r.jsx)(n.code,{children:"id"})," are always required:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nmodel: sdm\nvalue: Power\nscale: -1 # floating point factor applied to result, e.g. for kW to W conversion\n"})}),"\n",(0,r.jsx)(n.h2,{id:"manual-configuration",children:"Manual Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Falls das Modbus-Ger\xe4t nicht direkt unterst\xfctzt wird oder von den vordefinierten Modellen abweichende Werte gelesen oder geschrieben werden sollen, k\xf6nnen die Modbus Register auch vollst\xe4ndig manuell konfiguriert werden.\nDazu bedarf es neben den allgemeinen 'modbus' Einstellungen (siehe oben) auch der Definition eines ",(0,r.jsx)(n.code,{children:"registers"})," an Stelle eines ",(0,r.jsx)(n.code,{children:"value"}),", wie bei vordefinierten Ger\xe4ten. Es ist nicht zul\xe4ssig, sowohl ",(0,r.jsx)(n.code,{children:"value"})," als auch ",(0,r.jsx)(n.code,{children:"register"})," anzugeben.\nDie Definition eines Registers ben\xf6tigt folgende Parameter:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"address"}),": die Registeradresse"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Der Registertyp, zul\xe4ssig sind ",(0,r.jsx)(n.code,{children:"coil"}),", ",(0,r.jsx)(n.code,{children:"input"}),", ",(0,r.jsx)(n.code,{children:"holding"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"decode"}),": Die Art der Codierung der Daten. Zul\xe4ssig sind: ",(0,r.jsx)(n.code,{children:"int16|32|64, uint16|32|64, float32|64 and u|int32s + float32s"}),". Beim Typ ",(0,r.jsx)(n.code,{children:"coil"})," wird die Codierung ignoriert, muss aber trotzdem angegeben werden."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bitmask"}),": Eine optionale Angabe. Der angegebene Wert wird mit dem gelesenen UND verkn\xfcpft, um so einzelne Bits extrahieren zu k\xf6nnen.\nWeitere zul\xe4ssige Parameter einer manuellen Konfiguration sind:"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scale"}),": Flie\xdfkommazahl, die zur Konvertierung von gelesenen Werten (z.B. W in kW oder umgekehrt) verwendet werden kann. Dieser Wert wird mit dem gelesenen und decodierten Rohwert multipliziert."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"timeout"}),": modbus timeout. Ohne Einheit ist der Wertt in ns, ansonsten Einheit mit angeben, z.B. 10s f\xfcr 10 Sekunden."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"// translate above to english"}),"\n",(0,r.jsxs)(n.p,{children:["If the Modbus device is not directly supported or if values deviating from the predefined models are to be read or written, the Modbus registers can also be configured manually.\nFor this purpose, in addition to the general 'modbus' settings (see above), a ",(0,r.jsx)(n.code,{children:"registers"})," must be defined instead of a ",(0,r.jsx)(n.code,{children:"value"}),", as with predefined devices. It is not allowed to specify both ",(0,r.jsx)(n.code,{children:"value"})," and ",(0,r.jsx)(n.code,{children:"register"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The definition of a register requires the following parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"address"}),": the register address"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": The register type, allowed are ",(0,r.jsx)(n.code,{children:"coil"}),", ",(0,r.jsx)(n.code,{children:"input"}),", ",(0,r.jsx)(n.code,{children:"holding"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"decode"}),": The type of encoding of the data. Allowed are: ",(0,r.jsx)(n.code,{children:"int16|32|64, uint16|32|64, float32|64 and u|int32s + float32s"}),". For type ",(0,r.jsx)(n.code,{children:"coil"})," the encoding is ignored, but must still be specified."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bitmask"}),": An optional specification. The specified value is ANDed with the read value to extract individual bits."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Other allowed parameters of a manual configuration are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scale"}),": Floating point number that can be used to convert read values (e.g. W to kW or vice versa). This value is multiplied with the read and decoded raw value."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"timeout"}),": modbus timeout. Without unit the value is in ns, otherwise specify unit, e.g. 10s for 10 seconds."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nregister:\n  address: 40070\n  type: holding # coil, holding or input\n  decode: int32 # int16|32|64, uint16|32|64, float32|64 and u|int32s + float32s\n  bitmask: 2 # Optional: a bitmask that is applied to the read value. Here the mask is 0000000000000010b, ignored if value is 0\nscale: -1.0 # floating point factor applied to result, e.g. for kW to W conversion\ntimeout: 2s # timeout, without unit in ns\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.code,{children:"int32s/uint32s"})," decodings, the byte order is swapped, which is useful for E3/DC devices."]}),"\n",(0,r.jsx)(n.h3,{id:"writing-registers",children:"Writing Registers"}),"\n",(0,r.jsxs)(n.p,{children:["Both holding registers and coils can be written. For this, either ",(0,r.jsx)(n.code,{children:"type: writeholding"})," for holding registers or ",(0,r.jsx)(n.code,{children:"type: writecoil"})," for coils must be specified.\n",(0,r.jsx)(n.code,{children:"type: writeholding"})," always writes a 16-bit register (int or bool16). Therefore, for ",(0,r.jsx)(n.code,{children:"decode"}),", ",(0,r.jsx)(n.code,{children:"uint16"})," must always be specified.\n",(0,r.jsx)(n.code,{children:"type: writecoil"})," writes a coil. Specifications for ",(0,r.jsx)(n.code,{children:"decode"})," are ignored."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"source: modbus\n---\nregister:\n  address: 40070\n  type: writeholding # writeholding or writecoil\n"})}),"\n",(0,r.jsx)(n.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.p,{children:"A complete example for a custom charger with modbus interface (here a Phoenix EM-CP-PP-ETH with the IP address 192.168.1.10) could look like this:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"chargers:\n  - type: custom\n    name: CustomCharger\n    status:\n      # Read the status of the charger\n      # Either A,B,C or F\n      source: modbus\n      id: 180\n      uri: 192.168.1.10:502\n      timeout: 3s\n      register:\n        address: 100\n        type: input # Read an input register\n        decode: int16\n    enabled:\n      # Is the charger enabled (1) or not (0)\n      source: modbus\n      id: 180\n      uri: 192.168.1.10:502\n      register:\n        address: 400\n        type: coil # Read a coil\n        decode: bool16 # Doesn't matter but required\n    enable:\n      # Enable the charger\n      source: modbus\n      id: 180\n      uri: 192.168.1.10:502\n      register:\n        address: 400\n        type: writecoil # Write a coil\n        decode: uint8 # Doesn't matter but required\n    maxcurrent:\n      # Set the maximum current\n      source: modbus\n      id: 180\n      uri: 192.168.1.10:502\n      register:\n        address: 300\n        type: writeholding # Write a holding register\n        decode: uint16\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>o});var r=i(67294);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);